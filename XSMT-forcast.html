<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>雪山牧场天气预报 | Snow Mountain Ranch Weather</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&family=Noto+Sans+SC:wght@400;500;600;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-dark: #0b0c0e;
      --bg-panel: #141619;
      --bg-panel-hover: #1a1d21;
      --border: #2d3238;
      --text-primary: #e4e7eb;
      --text-secondary: #9ca3af;
      --accent-blue: #5794f2;
      --accent-green: #73bf69;
      --accent-orange: #f59e0b;
      --accent-red: #e24d42;
      --accent-purple: #b877d9;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Noto Sans SC', 'JetBrains Mono', -apple-system, sans-serif;
      background: var(--bg-dark);
      color: var(--text-primary);
      min-height: 100vh;
      line-height: 1.5;
      overflow-x: hidden;
    }

    .header {
      background: linear-gradient(135deg, var(--bg-panel) 0%, #1e2228 100%);
      border-bottom: 1px solid var(--border);
      padding: 0.5rem 1rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 0.5rem;
    }

    .header h1 {
      font-size: 1rem;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .header h1::before {
      content: '❄';
      font-size: 1.2rem;
    }

    .location-info {
      font-size: 0.75rem;
      color: var(--text-secondary);
      font-family: 'JetBrains Mono', monospace;
    }

    .refresh-status {
      font-size: 0.7rem;
      color: var(--text-secondary);
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .refresh-dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--accent-green);
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    .main {
      padding: 0.75rem 1rem;
      max-width: 1600px;
      margin: 0 auto;
    }

    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(12, 1fr);
      gap: 0.35rem;
      margin-bottom: 0.75rem;
    }
    .current-weather { grid-column: span 2; }
    @media (max-width: 1200px) {
      .dashboard-grid { grid-template-columns: repeat(6, 1fr); }
      .current-weather { grid-column: span 6; }
    }
    @media (max-width: 600px) {
      .dashboard-grid { grid-template-columns: repeat(2, 1fr); }
      .current-weather { grid-column: span 2; }
      .forecast-grid { grid-template-columns: 1fr; }
    }

    .panel {
      background: var(--bg-panel);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 0.35rem 0.5rem;
      transition: border-color 0.2s, background 0.2s;
    }

    .panel:hover {
      border-color: #3d4349;
      background: var(--bg-panel-hover);
    }

    .panel-title {
      font-size: 0.6rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.02em;
      color: var(--text-secondary);
      margin-bottom: 0.15rem;
    }

    .panel-value {
      font-size: 1rem;
      font-weight: 600;
      font-family: 'JetBrains Mono', monospace;
    }

    .panel-value.temp { color: var(--accent-orange); }
    .panel-value.humidity { color: var(--accent-blue); }
    .panel-value.wind { color: var(--accent-green); }
    .panel-value.pressure { color: var(--accent-purple); }
    .panel-value.precip { color: var(--accent-blue); }
    .panel-value.pwv { color: #56d4dd; }

    .panel-unit {
      font-size: 0.75rem;
      color: var(--text-secondary);
      margin-left: 0.15rem;
    }

    .current-weather {
      grid-column: span 2;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .weather-desc {
      font-size: 0.9rem;
      color: var(--text-primary);
    }

    .forecast-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 0.5rem;
    }
    .forecast-grid .chart-panel:last-child {
      grid-column: span 2;
    }

    .chart-panel {
      background: linear-gradient(145deg, var(--bg-panel) 0%, #0f1114 100%);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.5rem 0.65rem;
      box-shadow: 0 1px 4px rgba(0,0,0,0.2);
    }

    .chart-panel .chart-title {
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--text-secondary);
      margin-bottom: 0.25rem;
    }

    .chart-container {
      position: relative;
      width: 100%;
      height: 140px;
    }

    .chart-container canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .chart-legend {
      display: none;
    }

    .chart-legend span { display: flex; align-items: center; gap: 0.3rem; }
    .chart-legend .dot { width: 8px; height: 2px; border-radius: 1px; }

    .chart-tooltip {
      position: absolute;
      background: rgba(20,22,25,0.96);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.5rem 0.85rem;
      font-size: 0.8rem;
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-primary);
      pointer-events: none;
      z-index: 10;
      box-shadow: 0 4px 16px rgba(0,0,0,0.5);
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.15s;
      line-height: 1.4;
    }
    .chart-tooltip.visible { opacity: 1; }
    .chart-tooltip .val { font-weight: 600; color: var(--accent-orange); }

    .hourly-strip {
      display: flex;
      gap: 0.5rem;
      min-width: max-content;
      padding: 0.5rem 0;
    }

    .hour-item {
      flex: 0 0 70px;
      text-align: center;
      padding: 0.75rem;
      background: rgba(0,0,0,0.2);
      border-radius: 4px;
      border: 1px solid transparent;
    }

    .hour-item:hover {
      border-color: var(--accent-blue);
      background: rgba(87, 148, 242, 0.1);
    }

    .hour-time {
      font-size: 0.7rem;
      color: var(--text-secondary);
      margin-bottom: 0.25rem;
      font-family: 'JetBrains Mono', monospace;
    }

    .hour-temp {
      font-size: 1rem;
      font-weight: 600;
      color: var(--accent-orange);
    }

    .hour-precip {
      font-size: 0.7rem;
      color: var(--accent-blue);
      margin-top: 0.2rem;
    }

    .loading {
      text-align: center;
      padding: 3rem;
      color: var(--text-secondary);
    }

    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 3px solid var(--border);
      border-top-color: var(--accent-blue);
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin: 0 auto 1rem;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .error {
      background: rgba(226, 77, 66, 0.15);
      border: 1px solid var(--accent-red);
      color: var(--accent-red);
      padding: 1rem;
      border-radius: 6px;
      margin: 1rem 0;
    }

    .attribution {
      text-align: center;
      font-size: 0.65rem;
      color: var(--text-secondary);
      margin-top: 0.5rem;
      padding: 0.35rem;
    }

    .attribution a {
      color: var(--accent-blue);
      text-decoration: none;
    }

    .attribution a:hover {
      text-decoration: underline;
    }
  </style>
</head>
<body>
  <header class="header">
    <h1>雪山牧场天气预报</h1>
    <div class="location-info">
      坐标: 37°58′36.2″N, 96°35′08.6″E · 海拔 4820 m
    </div>
    <div class="refresh-status">
      <span class="refresh-dot"></span>
      <span id="lastUpdate">加载中...</span>
      <span>· 每 5 分钟自动刷新</span>
    </div>
  </header>

  <main class="main">
    <div id="content">
      <div class="loading">
        <div class="loading-spinner"></div>
        <p>正在获取天气数据...</p>
      </div>
    </div>

    <footer class="attribution">
      天气数据由 <a href="https://open-meteo.com/" target="_blank" rel="noopener">Open-Meteo</a> 提供 · PWV 来自 ECMWF IFS 模型 · designed by Wenjin Yang
    </footer>
  </main>

  <script>
    const LAT = 37.9767;  // 37d58m36.2s
    const LON = 96.5857;  // 96d35m08.6s
    const REFRESH_INTERVAL = 5 * 60 * 1000; // 5 分钟

    const WEATHER_CODES = {
      0: '晴', 1: '大部晴朗', 2: '局部多云', 3: '多云',
      45: '雾', 48: '雾凇',
      51: '毛毛雨', 53: '毛毛雨', 55: '毛毛雨',
      61: '小雨', 63: '中雨', 65: '大雨',
      66: '冻雨', 67: '冻雨',
      71: '小雪', 73: '中雪', 75: '大雪', 77: '雪粒',
      80: '阵雨', 81: '阵雨', 82: '强阵雨',
      85: '阵雪', 86: '阵雪',
      95: '雷暴', 96: '雷暴伴冰雹', 99: '强雷暴伴冰雹'
    };

    function getWeatherDesc(code) {
      return WEATHER_CODES[code] || '未知';
    }

    function windDirToName(deg) {
      if (deg == null || isNaN(deg)) return '—';
      const dirs = ['北','东北','东','东南','南','西南','西','西北'];
      const i = Math.round(((deg % 360) / 45)) % 8;
      return dirs[i] + ' (' + Math.round(deg) + '°)';
    }

    function formatTime(isoStr) {
      const d = new Date(isoStr);
      return `${d.getMonth()+1}/${d.getDate()} ${String(d.getHours()).padStart(2,'0')}:00`;
    }

    function drawLineChart(containerId, labels, values, opts = {}) {
      const container = document.getElementById(containerId);
      if (!container) return;
      const color = opts.color || '#5794f2';
      const unit = opts.unit || '';
      const labelFn = opts.labelFn || (x => x);
      const valueFn = opts.valueFn || (v => v != null ? v.toFixed(2) + (unit || '') : '—');
      const fill = opts.fill || false;
      const valid = values.map(v => v != null && !isNaN(v) ? v : null);
      const nums = valid.filter(v => v != null);
      if (nums.length === 0) {
        container.innerHTML = '<div style="padding:2rem;color:#9ca3af;text-align:center;font-size:0.85rem">暂无数据</div>';
        return;
      }
      let yMin, yMax, yTicks;
      if (opts.yMin != null && opts.yMax != null) {
        yMin = opts.yMin;
        yMax = opts.yMax;
        const step = (yMax - yMin) / 4;
        yTicks = [0,1,2,3,4].map(i => yMin + step * i);
      } else {
        const dataMin = Math.min(...nums);
        const dataMax = Math.max(...nums);
        const span = dataMax - dataMin;
        if (span === 0 || !isFinite(span)) {
          const c = dataMin;
          const d = Math.abs(c) >= 1 ? 1 : (Math.abs(c) >= 0.1 ? 0.1 : 0.01);
          yMin = c - d;
          yMax = c + d;
          yTicks = [0,1,2,3,4].map(i => yMin + (yMax - yMin) * (i / 4));
        } else {
          const step = span / 4;
          const mag = Math.pow(10, Math.floor(Math.log10(Math.abs(step)) || 0));
          const norm = step / mag;
          const steps = [1, 2, 2.5, 5, 10];
          const niceStep = steps.reduce((a, b) => Math.abs(norm - b) < Math.abs(norm - a) ? b : a) * mag;
          yMin = Math.floor(dataMin / niceStep) * niceStep;
          yMax = Math.ceil(dataMax / niceStep) * niceStep;
          if (yMax <= yMin) { yMin -= niceStep; yMax += niceStep; }
          yTicks = [];
          for (let t = yMin; t <= yMax + niceStep * 0.01; t += niceStep) {
            yTicks.push(Math.round(t * 1e10) / 1e10);
          }
        }
      }
      const fmtTick = opts.fmtTick || ((v) => {
        const r = Math.round(v);
        if (Math.abs(v) >= 100 || (Math.abs(v) >= 1 && Math.abs(v - r) < 1e-9)) return String(r);
        if (Math.abs(v) >= 0.1) return v.toFixed(1);
        if (Math.abs(v) >= 0.01) return v.toFixed(2);
        return v.toFixed(3);
      });
      const w = container.offsetWidth;
      const h = container.offsetHeight;
      const padL = 60;
      const padR = 12;
      const padT = 14;
      const padB = 24;
      const chartW = w - padL - padR;
      const chartH = h - padT - padB;
      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const tooltip = document.createElement('div');
      tooltip.className = 'chart-tooltip';
      const wrapper = document.createElement('div');
      wrapper.style.cssText = 'position:relative;width:100%;height:100%';
      wrapper.appendChild(canvas);
      wrapper.appendChild(tooltip);
      container.innerHTML = '';
      container.appendChild(wrapper);
      const ctx = canvas.getContext('2d');
      ctx.shadowBlur = 0;
      ctx.shadowColor = 'transparent';
      ctx.font = 'bold 11px JetBrains Mono, monospace';
      ctx.fillStyle = '#e4e7eb';
      const n = labels.length;
      const xStep = Math.max(1, Math.floor(n / 8));
      yTicks.forEach((v, yi) => {
        const y = h - padB - ((v - yMin) / (yMax - yMin)) * chartH;
        if (y >= padT - 2 && y <= h - padB + 2) {
          ctx.textAlign = 'right';
          ctx.fillStyle = '#e4e7eb';
          ctx.fillText(fmtTick(v) + (unit || ''), padL - 8, y + 4);
        }
      });
      ctx.textAlign = 'center';
      ctx.fillStyle = '#e4e7eb';
      for (let i = 0; i < n; i += xStep) {
        const x = padL + (i / (n - 1 || 1)) * chartW;
        ctx.fillText(labelFn(labels[i]), x, h - 6);
      }
      ctx.textAlign = 'left';
      ctx.strokeStyle = 'rgba(61,67,73,0.7)';
      ctx.lineWidth = 1;
      yTicks.forEach((v) => {
        const gy = h - padB - ((v - yMin) / (yMax - yMin)) * chartH;
        if (gy >= padT && gy <= h - padB) {
          ctx.beginPath();
          ctx.moveTo(padL, gy);
          ctx.lineTo(w - padR, gy);
          ctx.stroke();
        }
      });
      for (let xi = 0; xi <= 6; xi++) {
        const gx = padL + (xi / 6) * chartW;
        ctx.beginPath();
        ctx.moveTo(gx, padT);
        ctx.lineTo(gx, h - padB);
        ctx.stroke();
      }
      ctx.strokeStyle = '#3d4349';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(padL, padT);
      ctx.lineTo(padL, h - padB);
      ctx.lineTo(w - padR, h - padB);
      ctx.stroke();
      const yScale = v => h - padB - ((v - yMin) / (yMax - yMin)) * chartH;
      const xAt = i => padL + (i / (n - 1 || 1)) * chartW;
      const pts = [];
      for (let i = 0; i < n; i++) {
        const v = valid[i];
        if (v != null) pts.push({ x: xAt(i), y: yScale(v) });
      }
      if (fill && pts.length > 0) {
        const grad = ctx.createLinearGradient(0, padT, 0, h - padB);
        grad.addColorStop(0, color + '50');
        grad.addColorStop(1, color + '08');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(pts[0].x, h - padB);
        pts.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.lineTo(pts[pts.length - 1].x, h - padB);
        ctx.closePath();
        ctx.fill();
      }
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';
      ctx.shadowColor = 'transparent';
      ctx.shadowBlur = 0;
      ctx.beginPath();
      if (pts.length >= 2) {
        ctx.moveTo(pts[0].x, pts[0].y);
        for (let i = 1; i < pts.length; i++) {
          ctx.lineTo(pts[i].x, pts[i].y);
        }
      }
      ctx.stroke();
      wrapper.addEventListener('mousemove', (e) => {
        const rect = wrapper.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        if (mx < padL || mx > w - padR || my < padT || my > h - padB) {
          tooltip.classList.remove('visible');
          return;
        }
        const i = Math.round(((mx - padL) / chartW) * (n - 1));
        const clamped = Math.max(0, Math.min(i, n - 1));
        const v = valid[clamped];
        if (v == null) { tooltip.classList.remove('visible'); return; }
        tooltip.innerHTML = labelFn(labels[clamped]) + '<br><span class="val">' + valueFn(v) + '</span>';
        tooltip.classList.add('visible');
        if (mx < w / 2) { tooltip.style.left = (mx + 12) + 'px'; tooltip.style.right = 'auto'; }
        else { tooltip.style.right = (w - mx + 12) + 'px'; tooltip.style.left = 'auto'; }
        tooltip.style.top = (my - 8) + 'px';
      });
      wrapper.addEventListener('mouseleave', () => tooltip.classList.remove('visible'));
    }

    async function fetchWeather() {
      const forecastUrl = `https://api.open-meteo.com/v1/forecast?latitude=${LAT}&longitude=${LON}&elevation=4820&hourly=temperature_2m,relative_humidity_2m,precipitation,cloud_cover,wind_speed_10m,wind_direction_10m,surface_pressure,weather_code&wind_speed_unit=ms&timezone=auto&forecast_days=3`;
      const pwvUrl = `https://api.open-meteo.com/v1/ecmwf?latitude=${LAT}&longitude=${LON}&elevation=4820&hourly=total_column_integrated_water_vapour&timezone=auto&forecast_days=3`;
      const [forecastRes, pwvRes] = await Promise.all([fetch(forecastUrl), fetch(pwvUrl)]);
      if (!forecastRes.ok) throw new Error('获取天气数据失败');
      const data = await forecastRes.json();
      if (pwvRes.ok) {
        const pwvData = await pwvRes.json();
        if (pwvData.hourly?.time && pwvData.hourly?.total_column_integrated_water_vapour) {
          const pwvMap = {};
          pwvData.hourly.time.forEach((t, i) => { pwvMap[t] = pwvData.hourly.total_column_integrated_water_vapour[i]; });
          data.hourly.pwv = data.hourly.time.map(t => pwvMap[t] ?? null);
        }
      }
      return data;
    }

    function render(data) {
      const h = data.hourly;
      const now = new Date();
      const currentIdx = h.time.findIndex(t => new Date(t) >= now);
      const idx = currentIdx >= 0 ? currentIdx : 0;

      const currentTemp = h.temperature_2m[idx];
      const currentHumidity = h.relative_humidity_2m[idx];
      const currentWind = h.wind_speed_10m[idx];
      const currentWindDir = h.wind_direction_10m ? h.wind_direction_10m[idx] : null;
      const currentPressure = h.surface_pressure[idx];
      const currentPrecip = h.precipitation[idx];
      const weatherCode = h.weather_code ? h.weather_code[idx] : 0;
      const currentPwv = h.pwv ? h.pwv[idx] : null;

      let html = `
        <div class="dashboard-grid">
          <div class="panel current-weather">
            <div>
              <div class="panel-title">当前天气</div>
              <span class="weather-desc">${getWeatherDesc(weatherCode)}</span>
            </div>
          </div>
          <div class="panel">
            <div class="panel-title">温度</div>
            <span class="panel-value temp">${Math.round(currentTemp)}</span>
            <span class="panel-unit">°C</span>
          </div>
          <div class="panel">
            <div class="panel-title">相对湿度</div>
            <span class="panel-value humidity">${currentHumidity}</span>
            <span class="panel-unit">%</span>
          </div>
          <div class="panel">
            <div class="panel-title">风速</div>
            <span class="panel-value wind">${currentWind}</span>
            <span class="panel-unit">m/s</span>
          </div>
          <div class="panel">
            <div class="panel-title">风向</div>
            <span class="panel-value wind" style="font-size:0.8rem">${windDirToName(currentWindDir)}</span>
          </div>
          <div class="panel">
            <div class="panel-title">气压</div>
            <span class="panel-value pressure">${Math.round(currentPressure)}</span>
            <span class="panel-unit">hPa</span>
          </div>
          <div class="panel">
            <div class="panel-title">降水</div>
            <span class="panel-value precip">${currentPrecip}</span>
            <span class="panel-unit">mm</span>
          </div>
          <div class="panel">
            <div class="panel-title">PWV 可沉降水量</div>
            <span class="panel-value pwv">${currentPwv != null ? currentPwv.toFixed(2) : '—'}</span>
            <span class="panel-unit">mm</span>
          </div>
        </div>

        <div class="forecast-grid">
          <div class="chart-panel">
            <div class="chart-title">温度 48h</div>
            <div class="chart-container" id="chartTempHourly"></div>
          </div>
          <div class="chart-panel">
            <div class="chart-title">相对湿度 48h</div>
            <div class="chart-container" id="chartHumidity"></div>
          </div>
          <div class="chart-panel">
            <div class="chart-title">风速 48h</div>
            <div class="chart-container" id="chartWindSpeed"></div>
          </div>
          <div class="chart-panel">
            <div class="chart-title">风向 48h</div>
            <div class="chart-container" id="chartWindDir"></div>
          </div>
          <div class="chart-panel">
            <div class="chart-title">气压 48h</div>
            <div class="chart-container" id="chartPressure"></div>
          </div>
          <div class="chart-panel">
            <div class="chart-title">降水 48h</div>
            <div class="chart-container" id="chartPrecipHourly"></div>
          </div>
          <div class="chart-panel">
            <div class="chart-title">PWV 48h</div>
            <div class="chart-container" id="chartPwv"></div>
          </div>
        </div>
      `;

      document.getElementById('content').innerHTML = html;

      const hourlyStart = Math.max(0, idx);
      const hourlyEnd = Math.min(h.time.length, hourlyStart + 48);
      const hourlyTimes = h.time.slice(hourlyStart, hourlyEnd);
      const hourlyTemp = h.temperature_2m.slice(hourlyStart, hourlyEnd);
      const hourlyHumidity = h.relative_humidity_2m.slice(hourlyStart, hourlyEnd);
      const hourlyWindSpeed = h.wind_speed_10m.slice(hourlyStart, hourlyEnd);
      const hourlyWindDir = h.wind_direction_10m ? h.wind_direction_10m.slice(hourlyStart, hourlyEnd) : [];
      const hourlyPressure = h.surface_pressure.slice(hourlyStart, hourlyEnd);
      const hourlyPrecip = h.precipitation.slice(hourlyStart, hourlyEnd);
      const hourlyPwv = h.pwv ? h.pwv.slice(hourlyStart, hourlyEnd) : [];

      requestAnimationFrame(() => {
        drawLineChart('chartTempHourly', hourlyTimes, hourlyTemp, { color: '#f59e0b', unit: '°C', labelFn: formatTime });
        drawLineChart('chartHumidity', hourlyTimes, hourlyHumidity, { color: '#5794f2', unit: '%', labelFn: formatTime });
        drawLineChart('chartWindSpeed', hourlyTimes, hourlyWindSpeed, { color: '#73bf69', unit: ' m/s', labelFn: formatTime, fmtTick: (v) => v.toFixed(1) });
        drawLineChart('chartWindDir', hourlyTimes, hourlyWindDir, { color: '#73bf69', unit: '°', labelFn: formatTime, valueFn: (v) => v != null ? windDirToName(v) : '—', yMin: 0, yMax: 360 });
        drawLineChart('chartPressure', hourlyTimes, hourlyPressure, { color: '#b877d9', unit: 'hPa', labelFn: formatTime });
        drawLineChart('chartPrecipHourly', hourlyTimes, hourlyPrecip, { color: '#5794f2', unit: 'mm', labelFn: formatTime, fill: true, fmtTick: (v) => v.toFixed(2) });
        drawLineChart('chartPwv', hourlyTimes, hourlyPwv, { color: '#56d4dd', unit: 'mm', labelFn: formatTime });
      });
    }

    function showError(msg) {
      document.getElementById('content').innerHTML = `
        <div class="error">${msg}</div>
        <button onclick="loadWeather()" style="padding:0.5rem 1rem;cursor:pointer;background:var(--accent-blue);border:none;border-radius:4px;color:white;">重试</button>
      `;
    }

    function updateLastRefresh() {
      const el = document.getElementById('lastUpdate');
      if (el) el.textContent = `上次更新: ${new Date().toLocaleTimeString('zh-CN')}`;
    }

    async function loadWeather() {
      try {
        const data = await fetchWeather();
        render(data);
        updateLastRefresh();
      } catch (e) {
        showError('无法获取天气数据: ' + e.message);
      }
    }

    loadWeather();
    setInterval(loadWeather, REFRESH_INTERVAL);
  </script>
</body>
</html>
